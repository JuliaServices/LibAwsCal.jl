var documenterSearchIndex = {"docs":
[{"location":"#LibAwsCal","page":"Home","title":"LibAwsCal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LibAwsCal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#LibAwsCal.AWS_AES_256_CIPHER_BLOCK_SIZE","page":"Home","title":"LibAwsCal.AWS_AES_256_CIPHER_BLOCK_SIZE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCal.AWS_AES_256_KEY_BIT_LEN","page":"Home","title":"LibAwsCal.AWS_AES_256_KEY_BIT_LEN","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCal.AWS_AES_256_KEY_BYTE_LEN","page":"Home","title":"LibAwsCal.AWS_AES_256_KEY_BYTE_LEN","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCal.AWS_C_CAL_PACKAGE_ID","page":"Home","title":"LibAwsCal.AWS_C_CAL_PACKAGE_ID","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCal.AWS_MD5_LEN","page":"Home","title":"LibAwsCal.AWS_MD5_LEN","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCal.AWS_SHA1_LEN","page":"Home","title":"LibAwsCal.AWS_SHA1_LEN","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCal.AWS_SHA256_HMAC_LEN","page":"Home","title":"LibAwsCal.AWS_SHA256_HMAC_LEN","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCal.AWS_SHA256_LEN","page":"Home","title":"LibAwsCal.AWS_SHA256_LEN","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCal.__JL_Ctag_76","page":"Home","title":"LibAwsCal.__JL_Ctag_76","text":"__JL_Ctag_76\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_aes_cbc_256_new_fn","page":"Home","title":"LibAwsCal.aws_aes_cbc_256_new_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_aes_ctr_256_new_fn","page":"Home","title":"LibAwsCal.aws_aes_ctr_256_new_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_aes_gcm_256_new_fn","page":"Home","title":"LibAwsCal.aws_aes_gcm_256_new_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_aes_keywrap_256_new_fn","page":"Home","title":"LibAwsCal.aws_aes_keywrap_256_new_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_cal_errors","page":"Home","title":"LibAwsCal.aws_cal_errors","text":"aws_cal_errors\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_cal_log_subject","page":"Home","title":"LibAwsCal.aws_cal_log_subject","text":"aws_cal_log_subject\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ecc_curve_name","page":"Home","title":"LibAwsCal.aws_ecc_curve_name","text":"aws_ecc_curve_name\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ecc_key_pair","page":"Home","title":"LibAwsCal.aws_ecc_key_pair","text":"aws_ecc_key_pair\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ecc_key_pair_derive_public_key_fn","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_derive_public_key_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ecc_key_pair_destroy_fn","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_destroy_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ecc_key_pair_sign_message_fn","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_sign_message_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ecc_key_pair_signature_length_fn","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_signature_length_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ecc_key_pair_verify_signature_fn","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_verify_signature_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ecc_key_pair_vtable","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_vtable","text":"aws_ecc_key_pair_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ed25519_key_export_format","page":"Home","title":"LibAwsCal.aws_ed25519_key_export_format","text":"aws_ed25519_key_export_format\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_ed25519_key_pair","page":"Home","title":"LibAwsCal.aws_ed25519_key_pair","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_hash","page":"Home","title":"LibAwsCal.aws_hash","text":"aws_hash\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_hash_new_fn","page":"Home","title":"LibAwsCal.aws_hash_new_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_hash_vtable","page":"Home","title":"LibAwsCal.aws_hash_vtable","text":"aws_hash_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_hmac","page":"Home","title":"LibAwsCal.aws_hmac","text":"aws_hmac\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_hmac_new_fn","page":"Home","title":"LibAwsCal.aws_hmac_new_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_hmac_vtable","page":"Home","title":"LibAwsCal.aws_hmac_vtable","text":"aws_hmac_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_rsa_encryption_algorithm","page":"Home","title":"LibAwsCal.aws_rsa_encryption_algorithm","text":"aws_rsa_encryption_algorithm\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_rsa_key_export_format","page":"Home","title":"LibAwsCal.aws_rsa_key_export_format","text":"aws_rsa_key_export_format\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_rsa_key_pair","page":"Home","title":"LibAwsCal.aws_rsa_key_pair","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_rsa_signature_algorithm","page":"Home","title":"LibAwsCal.aws_rsa_signature_algorithm","text":"aws_rsa_signature_algorithm\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_symmetric_cipher","page":"Home","title":"LibAwsCal.aws_symmetric_cipher","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_symmetric_cipher_state","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_state","text":"aws_symmetric_cipher_state\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCal.aws_aes_cbc_256_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_aes_cbc_256_new","text":"aws_aes_cbc_256_new(allocator, key, iv)\n\nCreates an instance of AES CBC with 256-bit key. If key and iv are NULL, they will be generated internally. You can get the generated key and iv back by calling:\n\naws_symmetric_cipher_get_key() and aws_symmetric_cipher_get_initialization_vector()\n\nrespectively.\n\nIf they are set, that key and iv will be copied internally and used by the cipher.\n\nReturns NULL on failure. You can check aws_last_error() to get the error code indicating the failure cause.\n\nPrototype\n\nstruct aws_symmetric_cipher *aws_aes_cbc_256_new( struct aws_allocator *allocator, const struct aws_byte_cursor *key, const struct aws_byte_cursor *iv);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_aes_ctr_256_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_aes_ctr_256_new","text":"aws_aes_ctr_256_new(allocator, key, iv)\n\nCreates an instance of AES CTR with 256-bit key. If key and iv are NULL, they will be generated internally. You can get the generated key and iv back by calling:\n\naws_symmetric_cipher_get_key() and aws_symmetric_cipher_get_initialization_vector()\n\nrespectively.\n\nIf they are set, that key and iv will be copied internally and used by the cipher.\n\nReturns NULL on failure. You can check aws_last_error() to get the error code indicating the failure cause.\n\nPrototype\n\nstruct aws_symmetric_cipher *aws_aes_ctr_256_new( struct aws_allocator *allocator, const struct aws_byte_cursor *key, const struct aws_byte_cursor *iv);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_aes_gcm_256_new-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_aes_gcm_256_new","text":"aws_aes_gcm_256_new(allocator, key, iv, aad)\n\nCreates an instance of AES GCM with 256-bit key. If key, iv are NULL, they will be generated internally. You can get the generated key and iv back by calling:\n\naws_symmetric_cipher_get_key() and aws_symmetric_cipher_get_initialization_vector()\n\nrespectively.\n\nIf aad is set it will be copied and applied to the cipher.\n\nIf they are set, that key and iv will be copied internally and used by the cipher.\n\nFor decryption purposes tag can be provided via aws_symmetric_cipher_set_tag method. Note: for decrypt operations, tag must be provided before first decrypt is called. (this is a windows bcrypt limitations, but for consistency sake same limitation is extended to other platforms) Tag generated during encryption can be retrieved using aws_symmetric_cipher_get_tag method after finalize is called.\n\nReturns NULL on failure. You can check aws_last_error() to get the error code indicating the failure cause.\n\nPrototype\n\nstruct aws_symmetric_cipher *aws_aes_gcm_256_new( struct aws_allocator *allocator, const struct aws_byte_cursor *key, const struct aws_byte_cursor *iv, const struct aws_byte_cursor *aad);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_aes_keywrap_256_new-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_aes_keywrap_256_new","text":"aws_aes_keywrap_256_new(allocator, key)\n\nCreates an instance of AES Keywrap with 256-bit key. If key is NULL, it will be generated internally. You can get the generated key back by calling:\n\naws_symmetric_cipher_get_key()\n\nIf key is set, that key will be copied internally and used by the cipher.\n\nReturns NULL on failure. You can check aws_last_error() to get the error code indicating the failure cause.\n\nPrototype\n\nstruct aws_symmetric_cipher *aws_aes_keywrap_256_new( struct aws_allocator *allocator, const struct aws_byte_cursor *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_cal_library_clean_up-Tuple{}","page":"Home","title":"LibAwsCal.aws_cal_library_clean_up","text":"aws_cal_library_clean_up()\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_cal_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_cal_library_init-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_cal_library_init","text":"aws_cal_library_init(allocator)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_cal_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_cal_thread_clean_up-Tuple{}","page":"Home","title":"LibAwsCal.aws_cal_thread_clean_up","text":"aws_cal_thread_clean_up()\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_cal_thread_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_curve_name_from_oid-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_ecc_curve_name_from_oid","text":"aws_ecc_curve_name_from_oid(oid, curve_name)\n\nGet the curve name from the oid. OID here is the payload of the DER encoded ASN.1 part (doesn't include type specifier or length. On success, the value of curve_name will be set.\n\nPrototype\n\nint aws_ecc_curve_name_from_oid(struct aws_byte_cursor *oid, enum aws_ecc_curve_name *curve_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_coordinate_byte_size_from_curve_name-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_coordinate_byte_size_from_curve_name","text":"aws_ecc_key_coordinate_byte_size_from_curve_name(curve_name)\n\nDocumentation not found.\n\nPrototype\n\nsize_t aws_ecc_key_coordinate_byte_size_from_curve_name(enum aws_ecc_curve_name curve_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_new_from_hex_coordinates-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_new_from_hex_coordinates","text":"aws_ecc_key_new_from_hex_coordinates(allocator, curve_name, pub_x_hex_cursor, pub_y_hex_cursor)\n\nCreates an Elliptic curve public key from x and y coordinates encoded as hex strings Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_new_from_hex_coordinates( struct aws_allocator *allocator, enum aws_ecc_curve_name curve_name, struct aws_byte_cursor pub_x_hex_cursor, struct aws_byte_cursor pub_y_hex_cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_acquire-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_acquire","text":"aws_ecc_key_pair_acquire(key_pair)\n\nAdds one to an ecc key pair's ref count.\n\nPrototype\n\nvoid aws_ecc_key_pair_acquire(struct aws_ecc_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_derive_public_key-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_derive_public_key","text":"aws_ecc_key_pair_derive_public_key(key_pair)\n\nDerives a public key from the private key if supported by this operating system (not supported on OSX). key_pair::pub_x and key_pair::pub_y will be set with the raw key buffers.\n\nPrototype\n\nint aws_ecc_key_pair_derive_public_key(struct aws_ecc_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_get_private_key-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_get_private_key","text":"aws_ecc_key_pair_get_private_key(key_pair, private_d)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_ecc_key_pair_get_private_key( const struct aws_ecc_key_pair *key_pair, struct aws_byte_cursor *private_d);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_get_public_key-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_get_public_key","text":"aws_ecc_key_pair_get_public_key(key_pair, pub_x, pub_y)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_ecc_key_pair_get_public_key( const struct aws_ecc_key_pair *key_pair, struct aws_byte_cursor *pub_x, struct aws_byte_cursor *pub_y);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_new_from_asn1-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_new_from_asn1","text":"aws_ecc_key_pair_new_from_asn1(allocator, encoded_keys)\n\nCreates an Elliptic Curve public/private key pair from a DER encoded key pair. Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL. Whether or not signing or verification can be perform depends on if encoded_keys is a public/private pair or a public key.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_pair_new_from_asn1( struct aws_allocator *allocator, const struct aws_byte_cursor *encoded_keys);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_new_from_private_key-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_new_from_private_key","text":"aws_ecc_key_pair_new_from_private_key(allocator, curve_name, priv_key)\n\nCreates an Elliptic Curve private key that can be used for signing. Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL. Note: priv_key::len must match the appropriate length for the selected curve_name.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_pair_new_from_private_key( struct aws_allocator *allocator, enum aws_ecc_curve_name curve_name, const struct aws_byte_cursor *priv_key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_new_from_public_key-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_new_from_public_key","text":"aws_ecc_key_pair_new_from_public_key(allocator, curve_name, public_key_x, public_key_y)\n\nCreates an Elliptic Curve public key that can be used for verifying. Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL. Note: public_key_x::len and public_key_y::len must match the appropriate length for the selected curve_name.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_pair_new_from_public_key( struct aws_allocator *allocator, enum aws_ecc_curve_name curve_name, const struct aws_byte_cursor *public_key_x, const struct aws_byte_cursor *public_key_y);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_new_generate_random-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_new_generate_random","text":"aws_ecc_key_pair_new_generate_random(allocator, curve_name)\n\nCreates an Elliptic Curve public/private key pair that can be used for signing and verifying. Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL. Note: On Apple platforms this function is only supported on MacOS. This is due to usage of SecItemExport, which is only available on MacOS 10.7+ (yes, MacOS only and no other Apple platforms). There are alternatives for ios and other platforms, but they are ugly to use. Hence for now it only supports this call on MacOS.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_pair_new_generate_random( struct aws_allocator *allocator, enum aws_ecc_curve_name curve_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_release-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_release","text":"aws_ecc_key_pair_release(key_pair)\n\nSubtracts one from an ecc key pair's ref count. If ref count reaches zero, the key pair is destroyed.\n\nPrototype\n\nvoid aws_ecc_key_pair_release(struct aws_ecc_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_sign_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_sign_message","text":"aws_ecc_key_pair_sign_message(key_pair, message, signature)\n\nUses the key_pair's private key to sign message. The output will be in signature. Signature must be large enough to hold the signature. Check aws_ecc_key_pair_signature_length() for the appropriate size. Signature will be DER encoded.\n\nIt is the callers job to make sure message is the appropriate cryptographic digest for this operation. It's usually something like a SHA256.\n\nPrototype\n\nint aws_ecc_key_pair_sign_message( const struct aws_ecc_key_pair *key_pair, const struct aws_byte_cursor *message, struct aws_byte_buf *signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_signature_length-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_signature_length","text":"aws_ecc_key_pair_signature_length(key_pair)\n\nDocumentation not found.\n\nPrototype\n\nsize_t aws_ecc_key_pair_signature_length(const struct aws_ecc_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_key_pair_verify_signature-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_ecc_key_pair_verify_signature","text":"aws_ecc_key_pair_verify_signature(key_pair, message, signature)\n\nUses the key_pair's public key to verify signature of message. Signature should be DER encoded.\n\nIt is the callers job to make sure message is the appropriate cryptographic digest for this operation. It's usually something like a SHA256.\n\nreturns AWS_OP_SUCCESS if the signature is valid.\n\nPrototype\n\nint aws_ecc_key_pair_verify_signature( const struct aws_ecc_key_pair *key_pair, const struct aws_byte_cursor *message, const struct aws_byte_cursor *signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ecc_oid_from_curve_name-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_ecc_oid_from_curve_name","text":"aws_ecc_oid_from_curve_name(curve_name, oid)\n\nGet the DER encoded OID from the curve_name. The OID in this case will not contain the type or the length specifier.\n\nPrototype\n\nint aws_ecc_oid_from_curve_name(enum aws_ecc_curve_name curve_name, struct aws_byte_cursor *oid);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ed25519_key_pair_acquire-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ed25519_key_pair_acquire","text":"aws_ed25519_key_pair_acquire(key_pair)\n\nAdds one to an Ed25519 key pair's ref count. Returns key_pair pointer.\n\nPrototype\n\nstruct aws_ed25519_key_pair *aws_ed25519_key_pair_acquire(struct aws_ed25519_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ed25519_key_pair_get_private_key-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_ed25519_key_pair_get_private_key","text":"aws_ed25519_key_pair_get_private_key(key_pair, format, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_ed25519_key_pair_get_private_key( const struct aws_ed25519_key_pair *key_pair, enum aws_ed25519_key_export_format format, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ed25519_key_pair_get_private_key_size-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ed25519_key_pair_get_private_key_size","text":"aws_ed25519_key_pair_get_private_key_size(format)\n\nGets the size of the exported private key.\n\nPrototype\n\nsize_t aws_ed25519_key_pair_get_private_key_size(enum aws_ed25519_key_export_format format);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ed25519_key_pair_get_public_key-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_ed25519_key_pair_get_public_key","text":"aws_ed25519_key_pair_get_public_key(key_pair, format, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_ed25519_key_pair_get_public_key( const struct aws_ed25519_key_pair *key_pair, enum aws_ed25519_key_export_format format, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ed25519_key_pair_get_public_key_size-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ed25519_key_pair_get_public_key_size","text":"aws_ed25519_key_pair_get_public_key_size(format)\n\nGets the size of the exported public key.\n\nPrototype\n\nsize_t aws_ed25519_key_pair_get_public_key_size(enum aws_ed25519_key_export_format format);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ed25519_key_pair_new_generate-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ed25519_key_pair_new_generate","text":"aws_ed25519_key_pair_new_generate(allocator)\n\nGenerate new Ed25519 key. Returns a new instance of aws_ed25519_key_pair if the key was successfully generated. Otherwise returns NULL. Note: keygen is not supported on all platforms and will return NULL for the key and raise AWS_ERROR_CAL_UNSUPPORTED_ALGORITHM. Examples of unsupported cases: - openssl pre 1.1.1 (Note: aws-lc and boringssl both expose the needed functions) - win/mac builds without special flag that forces linking to libcrypto to support this\n\nPrototype\n\nstruct aws_ed25519_key_pair *aws_ed25519_key_pair_new_generate(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_ed25519_key_pair_release-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_ed25519_key_pair_release","text":"aws_ed25519_key_pair_release(key_pair)\n\nSubtracts one from an Ed25519 key pair's ref count. If ref count reaches zero, the key pair is destroyed. Always returns NULL.\n\nPrototype\n\nstruct aws_ed25519_key_pair *aws_ed25519_key_pair_release(struct aws_ed25519_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_hash_destroy-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_hash_destroy","text":"aws_hash_destroy(hash)\n\nCleans up and deallocates hash.\n\nPrototype\n\nvoid aws_hash_destroy(struct aws_hash *hash);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_hash_finalize-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_hash_finalize","text":"aws_hash_finalize(hash, output, truncate_to)\n\nCompletes the hash computation and writes the final digest to output. Allocation of output is the caller's responsibility. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example, if you want a SHA256 digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_hash_finalize(struct aws_hash *hash, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_hash_update-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_hash_update","text":"aws_hash_update(hash, to_hash)\n\nUpdates the running hash with to_hash. this can be called multiple times.\n\nPrototype\n\nint aws_hash_update(struct aws_hash *hash, const struct aws_byte_cursor *to_hash);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_hmac_destroy-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_hmac_destroy","text":"aws_hmac_destroy(hmac)\n\nCleans up and deallocates hmac.\n\nPrototype\n\nvoid aws_hmac_destroy(struct aws_hmac *hmac);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_hmac_finalize-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_hmac_finalize","text":"aws_hmac_finalize(hmac, output, truncate_to)\n\nCompletes the hmac computation and writes the final digest to output. Allocation of output is the caller's responsibility. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example if you want a SHA256 digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_hmac_finalize(struct aws_hmac *hmac, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_hmac_update-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_hmac_update","text":"aws_hmac_update(hmac, to_hmac)\n\nUpdates the running hmac with to_hash. this can be called multiple times.\n\nPrototype\n\nint aws_hmac_update(struct aws_hmac *hmac, const struct aws_byte_cursor *to_hmac);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_md5_compute-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_md5_compute","text":"aws_md5_compute(allocator, input, output, truncate_to)\n\nComputes the md5 hash over input and writes the digest output to 'output'. Use this if you don't need to stream the data you're hashing and you can load the entire input to hash into memory.\n\nPrototype\n\nint aws_md5_compute( struct aws_allocator *allocator, const struct aws_byte_cursor *input, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_md5_new-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_md5_new","text":"aws_md5_new(allocator)\n\nAllocates and initializes an md5 hash instance.\n\nPrototype\n\nstruct aws_hash *aws_md5_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_acquire-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_acquire","text":"aws_rsa_key_pair_acquire(key_pair)\n\nAdds one to an RSA key pair's ref count. Returns key_pair pointer.\n\nPrototype\n\nstruct aws_rsa_key_pair *aws_rsa_key_pair_acquire(struct aws_rsa_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_block_length-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_block_length","text":"aws_rsa_key_pair_block_length(key_pair)\n\nDocumentation not found.\n\nPrototype\n\nsize_t aws_rsa_key_pair_block_length(const struct aws_rsa_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_decrypt-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_decrypt","text":"aws_rsa_key_pair_decrypt(key_pair, algorithm, ciphertext, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_rsa_key_pair_decrypt( const struct aws_rsa_key_pair *key_pair, enum aws_rsa_encryption_algorithm algorithm, struct aws_byte_cursor ciphertext, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_encrypt-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_encrypt","text":"aws_rsa_key_pair_encrypt(key_pair, algorithm, plaintext, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_rsa_key_pair_encrypt( const struct aws_rsa_key_pair *key_pair, enum aws_rsa_encryption_algorithm algorithm, struct aws_byte_cursor plaintext, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_get_private_key-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_get_private_key","text":"aws_rsa_key_pair_get_private_key(key_pair, format, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_rsa_key_pair_get_private_key( const struct aws_rsa_key_pair *key_pair, enum aws_rsa_key_export_format format, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_get_public_key-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_get_public_key","text":"aws_rsa_key_pair_get_public_key(key_pair, format, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_rsa_key_pair_get_public_key( const struct aws_rsa_key_pair *key_pair, enum aws_rsa_key_export_format format, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_max_encrypt_plaintext_size-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_max_encrypt_plaintext_size","text":"aws_rsa_key_pair_max_encrypt_plaintext_size(key_pair, algorithm)\n\nMax plaintext size that can be encrypted by the key (i.e. max data size supported by the key - bytes needed for padding).\n\nPrototype\n\nsize_t aws_rsa_key_pair_max_encrypt_plaintext_size( const struct aws_rsa_key_pair *key_pair, enum aws_rsa_encryption_algorithm algorithm);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_new_from_private_key_pkcs1-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_new_from_private_key_pkcs1","text":"aws_rsa_key_pair_new_from_private_key_pkcs1(allocator, key)\n\nCreates an RSA private key from RSAPrivateKey as defined in rfc 8017 (aka PKCS1). Returns a new instance of aws_rsa_key_pair if the key was successfully built. Otherwise returns NULL.\n\nPrototype\n\nstruct aws_rsa_key_pair *aws_rsa_key_pair_new_from_private_key_pkcs1( struct aws_allocator *allocator, struct aws_byte_cursor key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_new_from_private_key_pkcs8-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_new_from_private_key_pkcs8","text":"aws_rsa_key_pair_new_from_private_key_pkcs8(allocator, key)\n\nCreates an RSA private key from PrivateKeyInfo as defined in rfc 5208 (aka PKCS8). Returns a new instance of aws_rsa_key_pair if the key was successfully built. Otherwise returns NULL.\n\nPrototype\n\nstruct aws_rsa_key_pair *aws_rsa_key_pair_new_from_private_key_pkcs8( struct aws_allocator *allocator, struct aws_byte_cursor key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_new_from_public_key_pkcs1-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_new_from_public_key_pkcs1","text":"aws_rsa_key_pair_new_from_public_key_pkcs1(allocator, key)\n\nCreates an RSA public key from RSAPublicKey as defined in rfc 8017 (aka PKCS1). Returns a new instance of aws_rsa_key_pair if the key was successfully built. Otherwise returns NULL.\n\nPrototype\n\nstruct aws_rsa_key_pair *aws_rsa_key_pair_new_from_public_key_pkcs1( struct aws_allocator *allocator, struct aws_byte_cursor key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_release-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_release","text":"aws_rsa_key_pair_release(key_pair)\n\nSubtracts one from an RSA key pair's ref count. If ref count reaches zero, the key pair is destroyed. Always returns NULL.\n\nPrototype\n\nstruct aws_rsa_key_pair *aws_rsa_key_pair_release(struct aws_rsa_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_sign_message-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_sign_message","text":"aws_rsa_key_pair_sign_message(key_pair, algorithm, digest, out)\n\nUses the key_pair's private key to sign message. The output will be in out. out must be large enough to hold the signature. Check aws_rsa_key_pair_signature_length() for the appropriate size.\n\nIt is the callers job to make sure message is the appropriate cryptographic digest for this operation. It's usually something like a SHA256.\n\nPrototype\n\nint aws_rsa_key_pair_sign_message( const struct aws_rsa_key_pair *key_pair, enum aws_rsa_signature_algorithm algorithm, struct aws_byte_cursor digest, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_signature_length-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_signature_length","text":"aws_rsa_key_pair_signature_length(key_pair)\n\nDocumentation not found.\n\nPrototype\n\nsize_t aws_rsa_key_pair_signature_length(const struct aws_rsa_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_rsa_key_pair_verify_signature-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_rsa_key_pair_verify_signature","text":"aws_rsa_key_pair_verify_signature(key_pair, algorithm, digest, signature)\n\nUses the key_pair's public key to verify signature of message.\n\nIt is the callers job to make sure message is the appropriate cryptographic digest for this operation. It's usually something like a SHA256.\n\nreturns AWS_OP_SUCCESS if the signature is valid. raises AWS_ERROR_CAL_SIGNATURE_VALIDATION_FAILED if signature validation failed\n\nPrototype\n\nint aws_rsa_key_pair_verify_signature( const struct aws_rsa_key_pair *key_pair, enum aws_rsa_signature_algorithm algorithm, struct aws_byte_cursor digest, struct aws_byte_cursor signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_set_md5_new_fn-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_set_md5_new_fn","text":"aws_set_md5_new_fn(fn)\n\nSet the implementation of md5 to use. If you compiled without BYO_CRYPTO, you do not need to call this. However, if use this, we will honor it, regardless of compile options. This may be useful for testing purposes. If you did set BYO_CRYPTO, and you do not call this function you will segfault.\n\nPrototype\n\nvoid aws_set_md5_new_fn(aws_hash_new_fn *fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_set_sha1_new_fn-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_set_sha1_new_fn","text":"aws_set_sha1_new_fn(fn)\n\nSet the implementation of sha1 to use. If you compiled without BYO_CRYPTO, you do not need to call this. However, if use this, we will honor it, regardless of compile options. This may be useful for testing purposes. If you did set BYO_CRYPTO, and you do not call this function you will segfault.\n\nPrototype\n\nvoid aws_set_sha1_new_fn(aws_hash_new_fn *fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_set_sha256_hmac_new_fn-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_set_sha256_hmac_new_fn","text":"aws_set_sha256_hmac_new_fn(fn)\n\nSet the implementation of sha256 hmac to use. If you compiled without BYO_CRYPTO, you do not need to call this. However, if use this, we will honor it, regardless of compile options. This may be useful for testing purposes. If you did set BYO_CRYPTO, and you do not call this function you will segfault.\n\nPrototype\n\nvoid aws_set_sha256_hmac_new_fn(aws_hmac_new_fn *fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_set_sha256_new_fn-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_set_sha256_new_fn","text":"aws_set_sha256_new_fn(fn)\n\nSet the implementation of sha256 to use. If you compiled without BYO_CRYPTO, you do not need to call this. However, if use this, we will honor it, regardless of compile options. This may be useful for testing purposes. If you did set BYO_CRYPTO, and you do not call this function you will segfault.\n\nPrototype\n\nvoid aws_set_sha256_new_fn(aws_hash_new_fn *fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_sha1_compute-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_sha1_compute","text":"aws_sha1_compute(allocator, input, output, truncate_to)\n\nComputes the sha1 hash over input and writes the digest output to 'output'. Use this if you don't need to stream the data you're hashing and you can load the entire input to hash into memory. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example, if you want a SHA1 digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_sha1_compute( struct aws_allocator *allocator, const struct aws_byte_cursor *input, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_sha1_new-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_sha1_new","text":"aws_sha1_new(allocator)\n\nAllocates and initializes a sha1 hash instance.\n\nPrototype\n\nstruct aws_hash *aws_sha1_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_sha256_compute-NTuple{4, Any}","page":"Home","title":"LibAwsCal.aws_sha256_compute","text":"aws_sha256_compute(allocator, input, output, truncate_to)\n\nComputes the sha256 hash over input and writes the digest output to 'output'. Use this if you don't need to stream the data you're hashing and you can load the entire input to hash into memory. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example, if you want a SHA256 digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_sha256_compute( struct aws_allocator *allocator, const struct aws_byte_cursor *input, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_sha256_hmac_compute-NTuple{5, Any}","page":"Home","title":"LibAwsCal.aws_sha256_hmac_compute","text":"aws_sha256_hmac_compute(allocator, secret, to_hmac, output, truncate_to)\n\nComputes the sha256 hmac over input and writes the digest output to 'output'. Use this if you don't need to stream the data you're hashing and you can load the entire input to hash into memory. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example if you want a SHA256 HMAC digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_sha256_hmac_compute( struct aws_allocator *allocator, const struct aws_byte_cursor *secret, const struct aws_byte_cursor *to_hmac, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_sha256_hmac_new-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_sha256_hmac_new","text":"aws_sha256_hmac_new(allocator, secret)\n\nAllocates and initializes a sha256 hmac instance. Secret is the key to be used for the hmac process.\n\nPrototype\n\nstruct aws_hmac *aws_sha256_hmac_new(struct aws_allocator *allocator, const struct aws_byte_cursor *secret);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_sha256_new-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_sha256_new","text":"aws_sha256_new(allocator)\n\nAllocates and initializes a sha256 hash instance.\n\nPrototype\n\nstruct aws_hash *aws_sha256_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_decrypt-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_decrypt","text":"aws_symmetric_cipher_decrypt(cipher, to_decrypt, out)\n\nDecrypts the value in to_decrypt and writes the decrypted data into out. If out is dynamic it will be expanded. If it is not, and out is not large enough to handle the decrypted output, the call will fail. If you're trying to optimize to use a stack based array or something, make sure it's at least as large as the size of to_decrypt + an extra BLOCK to account for padding etc...\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_decrypt( struct aws_symmetric_cipher *cipher, struct aws_byte_cursor to_decrypt, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_destroy-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_destroy","text":"aws_symmetric_cipher_destroy(cipher)\n\nCleans up internal resources and state for cipher and then deallocates it.\n\nPrototype\n\nvoid aws_symmetric_cipher_destroy(struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_encrypt-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_encrypt","text":"aws_symmetric_cipher_encrypt(cipher, to_encrypt, out)\n\nEncrypts the value in to_encrypt and writes the encrypted data into out. If out is dynamic it will be expanded. If it is not, and out is not large enough to handle the encrypted output, the call will fail. If you're trying to optimize to use a stack based array or something, make sure it's at least as large as the size of to_encrypt + an extra BLOCK to account for padding etc...\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_encrypt( struct aws_symmetric_cipher *cipher, struct aws_byte_cursor to_encrypt, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_finalize_decryption-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_finalize_decryption","text":"aws_symmetric_cipher_finalize_decryption(cipher, out)\n\nDecrypts any remaining data that was reserved for final padding, loads GMACs etc... and if there is any writes any remaining decrypted data to out. If out is dynamic it will be expanded. If it is not, and out is not large enough to handle the decrypted output, the call will fail. If you're trying to optimize to use a stack based array or something, make sure it's at least as large as the size of 2 BLOCKs to account for padding etc...\n\nAfter invoking this function, you MUST call aws_symmetric_cipher_reset() before invoking any encrypt/decrypt operations on this cipher again.\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_finalize_decryption(struct aws_symmetric_cipher *cipher, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_finalize_encryption-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_finalize_encryption","text":"aws_symmetric_cipher_finalize_encryption(cipher, out)\n\nEncrypts any remaining data that was reserved for final padding, loads GMACs etc... and if there is any writes any remaining encrypted data to out. If out is dynamic it will be expanded. If it is not, and out is not large enough to handle the decrypted output, the call will fail. If you're trying to optimize to use a stack based array or something, make sure it's at least as large as the size of 2 BLOCKs to account for padding etc...\n\nAfter invoking this function, you MUST call aws_symmetric_cipher_reset() before invoking any encrypt/decrypt operations on this cipher again.\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_finalize_encryption(struct aws_symmetric_cipher *cipher, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_get_initialization_vector-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_get_initialization_vector","text":"aws_symmetric_cipher_get_initialization_vector(cipher)\n\nGets the original initialization vector as a cursor. The memory in this cursor is unsafe as it refers to the internal buffer. This was done because the use case doesn't require fetching these during an encryption or decryption operation and it dramatically simplifies the API.\n\nUnlike some other fields, this value does not change after the inital construction of the cipher.\n\nFor some algorithms, such as AES Keywrap, this will return an empty cursor.\n\nPrototype\n\nstruct aws_byte_cursor aws_symmetric_cipher_get_initialization_vector( const struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_get_key-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_get_key","text":"aws_symmetric_cipher_get_key(cipher)\n\nGets the original key.\n\nThe memory in this cursor is unsafe as it refers to the internal buffer. This was done because the use case doesn't require fetching these during an encryption or decryption operation and it dramatically simplifies the API.\n\nUnlike some other fields, this value does not change after the inital construction of the cipher.\n\nPrototype\n\nstruct aws_byte_cursor aws_symmetric_cipher_get_key(const struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_get_state-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_get_state","text":"aws_symmetric_cipher_get_state(cipher)\n\nRetuns the current state of the cipher. Ther state of the cipher can be ready for use, finalized, or has encountered an error. if the cipher is in a finished or error state, it must be reset before further use.\n\nPrototype\n\nenum aws_symmetric_cipher_state aws_symmetric_cipher_get_state(const struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_get_tag-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_get_tag","text":"aws_symmetric_cipher_get_tag(cipher)\n\nGets the current GMAC tag. If not AES GCM, this function will just return an empty cursor. The memory in this cursor is unsafe as it refers to the internal buffer. This was done because the use case doesn't require fetching these during an encryption or decryption operation and it dramatically simplifies the API. Only use this function between other calls to this API as any function call can alter the value of this tag.\n\nIf you need to access it in a different pattern, copy the values to your own buffer first.\n\nPrototype\n\nstruct aws_byte_cursor aws_symmetric_cipher_get_tag(const struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_is_good-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_is_good","text":"aws_symmetric_cipher_is_good(cipher)\n\nReturns true if the state of the cipher is good, and otherwise returns false. Most operations, other than aws_symmetric_cipher_reset() will fail if this function is returning false. aws_symmetric_cipher_reset() will reset the state to a good state if possible.\n\nPrototype\n\nbool aws_symmetric_cipher_is_good(const struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_reset-Tuple{Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_reset","text":"aws_symmetric_cipher_reset(cipher)\n\nResets the cipher state for starting a new encrypt or decrypt operation. Note encrypt/decrypt cannot be mixed on the same cipher without a call to reset in between them. However, this leaves the key, iv etc... materials setup for immediate reuse. Note: GCM tag is not preserved between operations. If you intend to do encrypt followed directly by decrypt, make sure to make a copy of tag before reseting the cipher and pass that copy for decryption.\n\nWarning: In most cases it's a really bad idea to reset a cipher and perform another operation using that cipher. Key and IV should not be reused for different operations. Instead of reseting the cipher, destroy the cipher and create new one with a new key/iv pair. Use reset at your own risk, and only after careful consideration.\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_reset(struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCal.aws_symmetric_cipher_set_tag-Tuple{Any, Any}","page":"Home","title":"LibAwsCal.aws_symmetric_cipher_set_tag","text":"aws_symmetric_cipher_set_tag(cipher, tag)\n\nSets the GMAC tag on the cipher. Does nothing for ciphers that do not support tag.\n\nPrototype\n\nvoid aws_symmetric_cipher_set_tag(struct aws_symmetric_cipher *cipher, struct aws_byte_cursor tag);\n\n\n\n\n\n","category":"method"}]
}
